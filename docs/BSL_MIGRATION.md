# BSL Migration and Behavior Changes

This document explains the migration from DB routing to a single-credit-DB flow,
the introduction of the Business Semantics Layer (BSL), and the key changes in
main, generator, and prompt logic. It also summarizes why the changes were made
and how the system behaves now.

## Background

Originally, the system used DB routing to pick a target database. The model was
generating SQL mainly from schema/KB context and often failed on:
- Identity handling (CU vs CS).
- Aggregation intent (GROUP BY vs row-level).
- Semantic rules (cohort, risk, stress, etc.).

To improve stability and make reasoning explicit, BSL was introduced as the
primary source of business rules and SQL intent.

## What changed at a high level

1) DB routing removed
- The API now targets a single database (credit).
- Routing logic is no longer used, which reduces ambiguity and failure modes.

2) BSL introduced as a first-class layer
- BSL is generated from KB + meanings into a plain-text rules file (schema path is stored but not parsed).
- BSL is always loaded and injected into SQL generation prompts.

3) Generator and prompts updated
- Prompts now enforce identity and aggregation rules from BSL.
- Generator includes a BSL compliance regeneration step.
- KB is no longer passed into SQL prompts to reduce noise and conflicts.
- Self-correction prompts now include BSL + meanings.
- Table-name auto-correction uses a narrow prompt without BSL on purpose.

## BSL Content Overview

Your BSL contains **50 Knowledge Base Entries** organized into:

### Metriken/Berechnungen (27)
Financial metrics covering:
- **Core Ratios**: DTI, CUR, LTV, Net Worth
- **Composite Scores**: Credit Health Score (CHS), Financial Stability Index (FSI), Customer Engagement Score (CES), Account Health Index (AHI)
- **Advanced Metrics**: Risk-Adjusted Return (RAR), Asset Liquidity Ratio (ALR), Credit Risk Intensity (CRI), Total Debt Service Ratio (TDSR)
- **Business Metrics**: Credit Quality Index (CQI), Housing Affordability Ratio (HAR), Financial Vulnerability Score (FVS), Customer Retention Risk (CRR), Investment Portfolio Quality (IPQ), Banking Relationship Strength (BRS), Credit Health Momentum (CHM)
- **Customer Lifetime Value (CLV)** and other specialized calculations

### Geschäftsregeln & Dimensionen (16)
Identifies customer segments and risk profiles:
- **Customer Segments**: Prime Customer, High-Value Customer, Digital First Customer, Investment Focused
- **Risk Indicators**: Financially Vulnerable, Over-Extended, Revolving Credit Dependent, Property Risk Exposure, Frequent Credit Seeker
- **Opportunities**: Credit Builder, Credit Building Opportunity, Digital Channel Opportunity, Investment Services Target, Premium Banking Candidate, Cross-Sell Priority
- **Attrition & Decline**: Relationship Attrition Risk, Declining Credit Health, Mortgage Risk Profile
- **Specialized**: Credit Utilization Alert, Financial Stress Indicator

### Wertinterpretationen (7)
Reference guides for understanding score ranges:
- Credit Score Categories, Income Stability Score, DTI Interpretation, Credit Utilization Impact
- LTV Significance, Risk Level Classifications, Payment History Quality, Cross-Sell Ratio, Account Mix Score, Churn Rate Significance

## BSL pipeline and files

Key files:
- BSL builder: `backend/bsl_builder.py`
- Generated BSL: `backend/mini-interact/credit/credit_bsl.txt`
- Context loader: `backend/utils/context_loader.py`
- Knowledge Base: `backend/mini-interact/credit/credit_kb.jsonl` (52 entries as source)

Flow:
1) BSL is generated by `bsl_builder.py` (KB + meanings; schema is not parsed yet).
2) API loads BSL via `context_loader.py`.
3) BSL is injected into the SQL prompt (highest priority).

### Manual overrides inside the builder

Overrides are embedded directly in `bsl_builder.py` and appended to the BSL
output. This avoids external override files while still allowing targeted rules.

Current overrides include:
- "digital native" maps to "Digital First Customer".
- Net worth is computed as `totassets - totliabs`.
- Cohort summary defaults to a two-row digital-native summary when no explicit
  time range is given.
- Credit classification defaults to summary unless explicit detail fields are
  requested.

## main.py changes (execution flow)

The API flow is now:
1) Load schema, meanings, KB, and BSL.
2) Run ambiguity detection in parallel with SQL generation.
3) Generate SQL using BSL rules.
4) Validate SQL and execute with paging.

DB routing was removed from the main path to reduce variability.

## Prompt changes (prompt rules)

Prompts now emphasize:
- Identity: clientref (CU) for output, coreregistry (CS) for joins.
- Aggregation vs detail rules, with explicit exceptions.
- BSL compliance is the dominant instruction source.

Additional explicit guidance was added:
- Category + details = row-level (no GROUP BY).
- Credit classification without explicit details = summary (count + avg).
- Cohort queries only use cohort_quarter when an explicit time range is given.

## Generator changes (SQL creation)

1) BSL-first prompting
- BSL is injected at the top of the SQL prompt (highest priority).
- KB is not passed into SQL prompts anymore (to reduce conflicts).
- SQL generation uses full schema + meanings + BSL (no ReAct/RAG anymore).

2) BSL compliance regeneration
- After initial SQL generation, the generator checks for BSL violations.
- If violations are detected, it triggers a regeneration with a targeted
  compliance instruction (still LLM-generated, not hardcoded SQL).

3) No hardcoded SQL templates
- The previous hardcoded SQL override logic was removed.
- All SQL is still LLM-generated, but checked against BSL rules.

## Concrete fixes achieved

1) Question 7 (cohort analysis)
- Without explicit years/quarters, output is reduced to a two-row summary by
  digital-native status.
- Prevents accidental time-series output.

2) Question 4 (credit classification)
- If details are not explicitly requested, the query returns a summary:
  credit_category + customer_count + average_credscore.
- If explicit detail fields are requested, row-level output is used.

## Why this helps

- Rules are centralized in BSL and can be audited.
- Prompt noise is reduced by removing KB from SQL prompts.
- Regeneration enforces compliance without hardcoding SQL strings.

## How to regenerate BSL

From `backend`:
```
$env:PYTHONIOENCODING='utf-8'; python bsl_builder.py
```

## How to validate changes

1) Restart the API after changes.
2) Re-run the evaluation questions.
3) Confirm that:
   - Q7 does not include cohort_quarter without an explicit time range.
   - Q4 returns summary unless explicit detail fields are requested.

## Known limitations

- Ambiguity detection can still warn on vague wording, but SQL generation should
  follow BSL rules even if ambiguity is flagged.
- If future datasets change fields or semantics, BSL rules must be updated and regenerated.


Ja wir haben eine echte (wenn auch schlanke) BSL implementiert, diese wird aber technisch über das Prompting umgesetzt.
BSL=Inhalt/Schicht
Prompting=Transport/Mechanismus

Was typischerweise unter BSL verstanden wird
Aus Architektursicht ist eine Business Semantics Layer:
Explizite fachliche Regeln (Begriffe, Metriken, Schwellen, Identitäten, Aggregationslogik …)
Getrennt vom reinen Datenmodell (Schema) gehalten
Zentral wartbar & auditierbar, nicht verstreut in Code/Hacks
Von Domänen-Experten lesbar, nicht nur für Entwickler

Was wir konkret macht
credit_bsl.txt wird aus credit_kb.jsonl + credit_column_meaning_base.json generiert.
Darin stehen u.a.:
Identity-Regeln (CU vs. CS, Join-Chain)
Aggregationsregeln (top N vs. GROUP BY, Cohorts)
Geschäftsregeln (Financially Vulnerable, Digital Native, etc.)
JSON-/Join-Regeln und Metrikformeln
Diese Regeln werden als eigenständiges Artefakt geladen (context_loader.py) und im Prompt explizit vor Schema/Meanings platziert (BSL-first).
Der Generator hat explizite BSL-Compliance-Schritte (Regeneration bei Verstößen).

Das erfüllt die Kernideen einer BSL: explizite, getrennte, wiederverwendbare Business-Semantik, nicht nur „mehr Text im Prompt“.

---

Wo es „nur“ Prompting ist
Die BSL wird nicht als eigene Laufzeit-Schicht (z.B. Rules Engine, Services) exekutiert, sondern vom LLM interpretiert.
Durchsetzung passiert „soft“ über Prompting + Validation, nicht als harte Policy Engine im Code.

Für Vetter:
Architektur-Sicht:
„Wir haben eine Business Semantics Layer als separate Wissensschicht eingeführt, die Identity-, Aggregations- und Geschäftsregeln explizit definiert und versionierbar macht.“
„Diese BSL wird zur Laufzeit in den LLM-Prompt injiziert und steuert damit die SQL-Generierung. Prompting ist hier das Transportmedium, nicht der Ersatz für die BSL.“