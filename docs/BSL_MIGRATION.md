# BSL Migration and Behavior Changes

This document explains the migration from DB routing to a single-credit-DB flow,
the introduction of the Business Semantics Layer (BSL), and the key changes in
main, generator, and prompt logic. It also summarizes why the changes were made
and how the system behaves now.

## Background

Originally, the system used DB routing to pick a target database. The model was
generating SQL mainly from schema/KB context and often failed on:
- Identity handling (CU vs CS).
- Aggregation intent (GROUP BY vs row-level).
- Semantic rules (cohort, risk, stress, etc.).

To improve stability and make reasoning explicit, BSL was introduced as the
primary source of business rules and SQL intent.

## What changed at a high level

1) DB routing removed
- The API now targets a single database (credit).
- Routing logic is no longer used, which reduces ambiguity and failure modes.

2) BSL introduced as a first-class layer
- BSL is generated from KB + schema + meanings into a plain-text rules file.
- BSL is always loaded and injected into SQL generation prompts.

3) Generator and prompts updated
- Prompts now enforce identity and aggregation rules from BSL.
- Generator includes a BSL compliance regeneration step.
- KB is no longer passed into SQL prompts to reduce noise and conflicts.

## BSL pipeline and files

Key files:
- BSL builder: `backend/bsl_builder.py`
- Generated BSL: `backend/mini-interact/credit/credit_bsl.txt`
- Context loader: `backend/utils/context_loader.py`

Flow:
1) BSL is generated by `bsl_builder.py`.
2) API loads BSL via `context_loader.py`.
3) BSL is injected into the SQL prompt (highest priority).

### Manual overrides inside the builder

Overrides are embedded directly in `bsl_builder.py` and appended to the BSL
output. This avoids external override files while still allowing targeted rules.

Current overrides include:
- "digital native" maps to "Digital First Customer".
- Net worth is computed as `totassets - totliabs`.
- Cohort summary defaults to a two-row digital-native summary when no explicit
  time range is given.
- Credit classification defaults to summary unless explicit detail fields are
  requested.

## main.py changes (execution flow)

The API flow is now:
1) Load schema, meanings, KB, and BSL.
2) Run ambiguity detection in parallel with SQL generation.
3) Generate SQL using BSL rules.
4) Validate SQL and execute with paging.

DB routing was removed from the main path to reduce variability.

## Prompt changes (prompt rules)

Prompts now emphasize:
- Identity: clientref (CU) for output, coreregistry (CS) for joins.
- Aggregation vs detail rules, with explicit exceptions.
- BSL compliance is the dominant instruction source.

Additional explicit guidance was added:
- Category + details = row-level (no GROUP BY).
- Credit classification without explicit details = summary (count + avg).
- Cohort queries only use cohort_quarter when an explicit time range is given.

## Generator changes (SQL creation)

1) BSL-first prompting
- BSL is injected at the top of the SQL prompt.
- KB is not passed into SQL prompts anymore (to reduce conflicts).

2) BSL compliance regeneration
- After initial SQL generation, the generator checks for BSL violations.
- If violations are detected, it triggers a regeneration with a targeted
  compliance instruction (still LLM-generated, not hardcoded SQL).

3) No hardcoded SQL templates
- The previous hardcoded SQL override logic was removed.
- All SQL is still LLM-generated, but checked against BSL rules.

## Concrete fixes achieved

1) Question 7 (cohort analysis)
- Without explicit years/quarters, output is reduced to a two-row summary by
  digital-native status.
- Prevents accidental time-series output.

2) Question 4 (credit classification)
- If details are not explicitly requested, the query returns a summary:
  credit_category + customer_count + average_credscore.
- If explicit detail fields are requested, row-level output is used.

## Why this helps

- Rules are centralized in BSL and can be audited.
- Prompt noise is reduced by removing KB from SQL prompts.
- Regeneration enforces compliance without hardcoding SQL strings.

## How to regenerate BSL

From `backend`:
```
$env:PYTHONIOENCODING='utf-8'; python bsl_builder.py
```

## How to validate changes

1) Restart the API after changes.
2) Re-run the evaluation questions.
3) Confirm that:
   - Q7 does not include cohort_quarter without an explicit time range.
   - Q4 returns summary unless explicit detail fields are requested.

## Known limitations

- Ambiguity detection can still warn on vague wording, but SQL generation should
  follow BSL rules even if ambiguity is flagged.
- If future datasets change fields or semantics, BSL rules must be updated and
  regenerated.
